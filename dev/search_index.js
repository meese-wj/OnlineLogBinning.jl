var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"CurrentModule = OnlineLogBinning","category":"page"},{"location":"api/#OnlineLogBinning","page":"API Reference","title":"OnlineLogBinning","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Documentation for OnlineLogBinning.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [OnlineLogBinning]","category":"page"},{"location":"api/#OnlineLogBinning.OLB_tested_numbers","page":"API Reference","title":"OnlineLogBinning.OLB_tested_numbers","text":"OLB_tested_numbers\n\nDefines the list of tested numerical types for OnlineLogBinning.jl.\n\nnote: Note\nThese types are specifically given as: Float16, Float32, Float64 for Real numbers.\nComplexF16, ComplexF32, ComplexF64 for Complex numbers.\n\n\n\n\n\n","category":"constant"},{"location":"api/#OnlineLogBinning.TRUSTING_CUTOFF","page":"API Reference","title":"OnlineLogBinning.TRUSTING_CUTOFF","text":"TRUSTING_CUTOFF = 128\n\nThe minimum number of bins required for any given binning level to be considered statistically trustworthy so as to minimally suffer from small-number fluctuations.\n\nnote: Note\nThis is value is similar to what's given in Carsten Bauer (2020) and four times greater than what's  in James Gubernatis, Naoki Kawashima, Philipp Werner (2016).\n\n\n\n\n\n","category":"constant"},{"location":"api/#OnlineLogBinning.BinningAccumulator","page":"API Reference","title":"OnlineLogBinning.BinningAccumulator","text":"BinningAccumulator{T}() where {T <: Number}\n\nMain data structure for the binning analysis. T == Float64 by default in the empty constructor.\n\nContents\n\nLvlAccums::Vector{LevelAccumulator{T}}\nA wrapper around the LevelAccumulators from each binning level\n\nExample\n\njulia> # Create a BinningAccumulator with the default type T == Float64\n\njulia> bacc = BinningAccumulator()  \nBinningAccumulator{Float64} with 0 binning levels.\n0th Binning Level (unbinned data):\nLevelAccumulator{Float64} with online fields:\n    level    = 0\n    num_bins = 0\n    Taccum   = 0.0\n    Saccum   = 0.0\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = NaN\n    Current Variance         = -0.0\n    Current Std. Deviation   = -0.0\n    Current Var. of the Mean = NaN\n    Current Std. Error       = NaN\n\njulia> # Add a data stream using the push! function\n\njulia> # (The data stream does not have to have a length == power of 2.)\n\njulia> push!(bacc, [1, 2, 3, 4])\nBinningAccumulator{Float64} with 2 binning levels.\n0th Binning Level (unbinned data):\nLevelAccumulator{Float64} with online fields:\n    level    = 0\n    num_bins = 4\n    Taccum   = 10.0\n    Saccum   = 5.0\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = 2.5\n    Current Variance         = 1.6666666666666667\n    Current Std. Deviation   = 1.2909944487358056\n    Current Var. of the Mean = 0.4166666666666667\n    Current Std. Error       = 0.6454972243679028\n\n1th Binning Level:\nLevelAccumulator{Float64} with online fields:\n    level    = 1\n    num_bins = 2\n    Taccum   = 5.0\n    Saccum   = 2.0\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = 2.5\n    Current Variance         = 2.0\n    Current Std. Deviation   = 1.4142135623730951\n    Current Var. of the Mean = 1.0\n    Current Std. Error       = 1.0\n\n2th Binning Level:\nLevelAccumulator{Float64} with online fields:\n    level    = 2\n    num_bins = 0\n    Taccum   = 0.0\n    Saccum   = 0.0\n    Paccum   = PairAccumulator{Float64}(false, [0.0, 2.5])\n\n    Calculated Level Statistics:\n    Current Mean             = NaN\n    Current Variance         = -0.0\n    Current Std. Deviation   = -0.0\n    Current Var. of the Mean = NaN\n    Current Std. Error       = NaN\n\n\n\n\n\n\n","category":"type"},{"location":"api/#OnlineLogBinning.BinningAnalysisResult","page":"API Reference","title":"OnlineLogBinning.BinningAnalysisResult","text":"BinningAnalysisResult{T <: AbstractFloat}\n\nSmall struct to determine if there is a _plateau_found from a BinningAccumulator, and what its value is.\n\n\n\n\n\n","category":"type"},{"location":"api/#OnlineLogBinning.LevelAccumulator","page":"API Reference","title":"OnlineLogBinning.LevelAccumulator","text":"LevelAccumulator{T <: Number}\n\nAccumulator structure for a given binning level.\n\nContents\n\nlevel::Int\nRegisters the binning level this accumulator is assigned\nnum_bins::Int \nHow many elements (i.e. bins) have been added to this accumulator\nTaccum::T\nStands for Total Accumulator.\nThis represents the T accumulator for the mean: mean ≡ T / num_bins.\nSaccum::T\nStands for Square Accumulator.\nThis represents the S accumulator for the variance: var ≡ S/(num_bins - 1).\nPaccum::PairAccumulator{T}\nAn outward facing PairAccumulator to meet incoming data streams. \nThis accumulator processes the incoming data and then exports the Tvalue and Svalue into updates for Taccum and Saccum, respectively.\n\n\n\n\n\n","category":"type"},{"location":"api/#OnlineLogBinning.PairAccumulator","page":"API Reference","title":"OnlineLogBinning.PairAccumulator","text":"PairAccumulator{T <: Number}\n\nAccumulator that directly faces an incoming data stream. Two values from that stream enter and are processed into the exported values of Tvalue and Svalue.\n\nContents\n\nfullpair::Bool\nA Boolean to keep track of which element of the pair is being accessed. Additionally, when fullpair == true then the contents are exported.\nvalues::MVector{2, T}\nThe individual values taken from the data stream to be processed. Both Tvalue and Svalue rely on them being accessible.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.eltype-Union{Tuple{BinningAccumulator{T}}, Tuple{T}} where T","page":"API Reference","title":"Base.eltype","text":"eltype(::BinningAccumulator{T}) → T\n\nReturns the type parameter for the BinningAccumulator.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{BinningAccumulator}","page":"API Reference","title":"Base.getindex","text":"getindex(bacc::BinningAccumulator; level)\n\nOverload the [] notation by accessing the BinningAccumulator's LvlAccums at a specific binning level keyword.\n\nExample\n\njulia> bacc = BinningAccumulator();\n\njulia> bacc[level = 0]\nLevelAccumulator{Float64} with online fields:\n    level    = 0\n    num_bins = 0\n    Taccum   = 0.0\n    Saccum   = 0.0\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = NaN\n    Current Variance         = -0.0\n    Current Std. Deviation   = -0.0\n    Current Var. of the Mean = NaN\n    Current Std. Error       = NaN\n\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{BinningAccumulator}","page":"API Reference","title":"Base.length","text":"length(bacc::BinningAccumulator)\n\nReturn the number of LevelAccumulators there are.\n\nExample\n\njulia> bacc = BinningAccumulator();\n\njulia> push!(bacc, [1, 2, 3, 4, 3, 2, 1]); # Data stream with 7 elements\n\njulia> length(bacc) # Only 2 binning levels (1 for unbinned data)\n3\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.push!-Tuple{BinningAccumulator, Any}","page":"API Reference","title":"Base.push!","text":"push!(bacc::BinningAccumulator, itr)\n\npush! each value of the data stream itr through the BinningAccumulator.\n\nExample\n\njulia> bacc = BinningAccumulator()\nBinningAccumulator{Float64} with 0 binning levels.\n0th Binning Level (unbinned data):\nLevelAccumulator{Float64} with online fields:\n    level    = 0\n    num_bins = 0\n    Taccum   = 0.0\n    Saccum   = 0.0\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = NaN\n    Current Variance         = -0.0\n    Current Std. Deviation   = -0.0\n    Current Var. of the Mean = NaN\n    Current Std. Error       = NaN\n\njulia> push!(bacc, [42, -26])\nBinningAccumulator{Float64} with 1 binning levels.\n0th Binning Level (unbinned data):\nLevelAccumulator{Float64} with online fields:\n    level    = 0\n    num_bins = 2\n    Taccum   = 16.0\n    Saccum   = 2312.0\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = 8.0\n    Current Variance         = 2312.0\n    Current Std. Deviation   = 48.08326112068523\n    Current Var. of the Mean = 1156.0\n    Current Std. Error       = 34.0\n\n1th Binning Level:\nLevelAccumulator{Float64} with online fields:\n    level    = 1\n    num_bins = 0\n    Taccum   = 0.0\n    Saccum   = 0.0\n    Paccum   = PairAccumulator{Float64}(false, [0.0, 8.0])\n\n    Calculated Level Statistics:\n    Current Mean             = NaN\n    Current Variance         = -0.0\n    Current Std. Deviation   = -0.0\n    Current Var. of the Mean = NaN\n    Current Std. Error       = NaN\n\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.push!-Tuple{BinningAccumulator, Number}","page":"API Reference","title":"Base.push!","text":"push!(bacc::BinningAccumulator, value::Number)\n\nAdd a single value from the data stream into the online binning analysis. The single value enters at the bin at the lowest level. \n\nExample\n\njulia> bacc = BinningAccumulator()\nBinningAccumulator{Float64} with 0 binning levels.\n0th Binning Level (unbinned data):\nLevelAccumulator{Float64} with online fields:\n    level    = 0\n    num_bins = 0\n    Taccum   = 0.0\n    Saccum   = 0.0\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = NaN\n    Current Variance         = -0.0\n    Current Std. Deviation   = -0.0\n    Current Var. of the Mean = NaN\n    Current Std. Error       = NaN\n\njulia> push!(bacc, 42)\nBinningAccumulator{Float64} with 0 binning levels.\n0th Binning Level (unbinned data):\nLevelAccumulator{Float64} with online fields:\n    level    = 0\n    num_bins = 0\n    Taccum   = 0.0\n    Saccum   = 0.0\n    Paccum   = PairAccumulator{Float64}(false, [0.0, 42.0])        \n\n    Calculated Level Statistics:\n    Current Mean             = NaN\n    Current Variance         = -0.0\n    Current Std. Deviation   = -0.0\n    Current Var. of the Mean = NaN\n    Current Std. Error       = NaN\n\n\nnote: Note\nNotice that the Taccum and Saccum remain zero while num_bins == 0.  These are only accumulated for each input pair. Or once Paccum.fullpair == true.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.push!-Tuple{PairAccumulator, Number}","page":"API Reference","title":"Base.push!","text":"push!(pacc::PairAccumulator, value::Number)\n\nOverload Base.push! for a PairAccumulator. One can only  push! a single value <: Number at a time into this type of accumulator.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.show-Tuple{IO, BinningAccumulator}","page":"API Reference","title":"Base.show","text":"show([io::IO = stdout], bacc::BinningAccumulator)\n\nOverload the Base.show function for human-readable displays.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.show-Tuple{IO, LevelAccumulator}","page":"API Reference","title":"Base.show","text":"show([io = stdout], lacc::LevelAccumulator)\n\nOverload Base.show for human-readable displays.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.RxValue","page":"API Reference","title":"OnlineLogBinning.RxValue","text":"RxValue(bacc::BinningAccumulator, [trustworthy_only = true]; [trusting_cutoff])\n\nCalculate the RxValues from the statistically trustworthy binning levels by default, or from all of them if trustworthy_only == false. \n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineLogBinning.RxValue-Tuple{BinningAccumulator, Int64}","page":"API Reference","title":"OnlineLogBinning.RxValue","text":"RxValue(bacc::BinningAccumulator, level)\n\nCompute the R_X quantity from the binning analysis. This quantity starts at 1 for low binning levels, then gradually rises, until the  bins become statistically uncorrelated at which point R_X should saturate. Once saturated, the effective number of uncorrelated elements in a correlated  data stream of size M is given in terms of R_X by M  R_X. \n\nnote: Note\nSee Carsten Bauer (2020) and James Gubernatis, Naoki Kawashima, Philipp Werner (2016) for details.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.Svalue-Tuple{LevelAccumulator, Any, Any}","page":"API Reference","title":"OnlineLogBinning.Svalue","text":"Svalue(lacc::LevelAccumulator)\n\nFunction to calculate the online S_1m+2 summation as:\n\nS_1m+2 = S_1m + S_m+1m+2 + fracm2(m+2)left( frac2m T_1m - T_m+1m+2 right)^2\n\nwhere T_m+1m+2 is the pairwise Tvalue for the PairAccumulator.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.Svalue-Tuple{PairAccumulator}","page":"API Reference","title":"OnlineLogBinning.Svalue","text":"Svalue(pacc::PairAccumulator)\n\nThe S function for a single pair following the accumulation of m data points follows as \n\nbeginaligned\nS_m+1 m+2 equiv sum_k = m+1^m+2 left( x_k - frac12 T_m+1m+2 right)^2\n\n= frac12left( x_m+2 - x_m+1 right)^2\nendaligned\n\nThus, S_m+1m+2 does not need to take T_m+1m+2 as an argument.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.Tvalue-Tuple{LevelAccumulator, Any}","page":"API Reference","title":"OnlineLogBinning.Tvalue","text":"Tvalue(lacc::LevelAccumulator)\n\nFunction to calculate the online T_1m+2 summation as:\n\nT_1m+2 = T_1m + T_m+1m+2\n\nwhere T_m+1m+2 is the pairwise Tvalue for the PairAccumulator.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.Tvalue-Tuple{PairAccumulator}","page":"API Reference","title":"OnlineLogBinning.Tvalue","text":"Tvalue(pacc::PairAccumulator)\n\nThe T function for a single pair following the accumulation of m data points follows as \n\nT_m+1 m+2 equiv sum_k = m+1^m+2 x_k = x_m+1 + x_m+2\n\nas expected.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning._binning_index_to_findex-Tuple{Any}","page":"API Reference","title":"OnlineLogBinning._binning_index_to_findex","text":"_binning_index_to_findex(level)\n\nConvert the binning_index ∈ {0, 1, ... } to a (Fortran) findex ∈ {1, 2, ... }.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning._plateau_found-Tuple{Any, Any}","page":"API Reference","title":"OnlineLogBinning._plateau_found","text":"_plateau_found(fit, levels) → Bool\n\nTest whether a plateau has been found from the fit using the LsqFit.jl package. This includes finding reasonable values for the sigmoid parameters.\n\nnote: Note\nWhat counts as a plateau?A plateau in the RxValues is defined to be present if the following three conditions on the sigmoid fit are all true:The amplitude is positive.\nThe θ₂ parameter is positive.\nThe inflection point given by θ₁ / θ₂ < maximum(levels).If any of these conditions are violated, then we do not trust that the RxValues have actually converged to a single value, meaning that the datastream is not sufficiently large enough to separate correlated data from one another.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.autocorrelation_time-Tuple{Any}","page":"API Reference","title":"OnlineLogBinning.autocorrelation_time","text":"autocorrelation_time(RxVal)\n\nCalculation of the autocorrelation time tau_X = frac12left( R_X - 1 right).\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.bin_depth-Tuple{BinningAccumulator}","page":"API Reference","title":"OnlineLogBinning.bin_depth","text":"bin_depth(bacc::BinningAccumulator)\n\nNumber of binned levels present. length of the [BinningAccumulator] minus 1.\n\nExample\n\njulia> bacc = BinningAccumulator();\n\njulia> push!(bacc, [1, 2, 3, 4, 3, 2, 1]); # Data stream with 7 elements\n\njulia> bin_depth(bacc) # Only 2 binning levels (1 for unbinned data)\n2\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.binning_level-Tuple{Int64}","page":"API Reference","title":"OnlineLogBinning.binning_level","text":"binning_level(index::Int)\n\nConversion from LvlAccums index to binning_level.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.effective_uncorrelated_values-Tuple{Any, Any}","page":"API Reference","title":"OnlineLogBinning.effective_uncorrelated_values","text":"effective_uncorrelated_values(mvals, RxVal)\n\nCalculation of the effective number of uncorrelated values in a correlated datastream: m_rm eff = m  R_X.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.fit_RxValues","page":"API Reference","title":"OnlineLogBinning.fit_RxValues","text":"fit_RxValues(levels, rxvalues, [p0])\n\nUse LsqFit.jl to fit a sigmoid to a set of RxValues generated by a BinningAccumulator.\n\nAdditional information\n\nThe default arguments passed take on the following values:\n\nInitial guess for sigmoid parameters: p0 = [1, 0, 1].\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineLogBinning.fit_RxValues-2","page":"API Reference","title":"OnlineLogBinning.fit_RxValues","text":"fit_RxValues(bacc::BinningAccumulator, [p0])\n\nUse LsqFit.jl to fit a sigmoid to a BinningAccumulator. Note, only statistically trustworthy binning levels are used. This function returns a BinningAnalysisResult struct.\n\nAdditional information\n\nThe default arguments passed take on the following values:\n\nInitial guess for sigmoid parameters: p0 = [1, 0, 1].\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineLogBinning.max_trustworthy_level-Tuple{Any}","page":"API Reference","title":"OnlineLogBinning.max_trustworthy_level","text":"max_trustworthy_level(nelements; [trusting_cutoff])\n\nCalculates the highest binning level that remains statistically trustworthy according to the TRUSTING_CUTOFF, t_c. \n\nGiven a number of elements in a data stream, N, this quantity is \n\nell_rm max = rm floor left log_2 left( fracNt_c right) right\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.reset!-Union{Tuple{BinningAccumulator{T}}, Tuple{T}} where T","page":"API Reference","title":"OnlineLogBinning.reset!","text":"reset!(bacc::BinningAccumulator{T})\n\nReset the BinningAccumulator by reconstruction.\n\nAdditional information\n\nWhile this is not a literal reset per se, with a large enough BinningAccumulator it will be certainly faster just to blow up the old one (in memory) and start over.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.reset!-Union{Tuple{PairAccumulator{T}}, Tuple{T}} where T","page":"API Reference","title":"OnlineLogBinning.reset!","text":"reset!(pacc::PairAccumulator)\n\nReturn the PairAccumulator to its initial state. Presumably one just exported the  Tvalue and Svalue from it before the reset!.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.sigmoid","page":"API Reference","title":"OnlineLogBinning.sigmoid","text":"sigmoid(x, [amp = 1], [θ₁ = 0], [θ₂ = 1])\n\nCalculate a Sigmoid at a given argument x. The Sigmoid function S(x A theta_1 theta_2) is of the form\n\nS(x A theta_1 theta_2) = fracA1 + expleft( theta_1 - theta_2 x right)\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineLogBinning.sigmoid-Tuple{AbstractVecOrMat, Any}","page":"API Reference","title":"OnlineLogBinning.sigmoid","text":"sigmoid(x, pvals) = sigmoid(x, pvals...)\n\nVectorized sigmoid function.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.std_error-Tuple{BinningAccumulator}","page":"API Reference","title":"OnlineLogBinning.std_error","text":"std_error( bacc::BinningAccumulator )\n\nOnline measurement of the [BinningAccumulator] standard error.\n\nAdditional information\n\nThis quantity is considered online despite that it is not regularly updated when data is push!ed from the stream.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.std_error-Tuple{LevelAccumulator}","page":"API Reference","title":"OnlineLogBinning.std_error","text":"std_error( lacc::LevelAccumulator ) = sqrt(var_of_mean(lacc))\n\nOnline measurement of the [LevelAccumulator] standard error.\n\nAdditional information\n\nThis quantity is considered online despite that it is not regularly updated when data is push!ed from the stream.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.trustworthy_indices-Tuple{BinningAccumulator}","page":"API Reference","title":"OnlineLogBinning.trustworthy_indices","text":"trustworthy_indices(bacc::BinningAccumulator; [trusting_cutoff])\n\nReturn the (Fortran) indices 1, 2, 3, ... corresponding to trustworthy_levels.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.trustworthy_level-Tuple{Any, Any}","page":"API Reference","title":"OnlineLogBinning.trustworthy_level","text":"trustworthy_level(level; [trustworthy_cutoff = 64])\n\nA binning level is said to be a trustworthy_level if the number of bins it contains is greater than or equal to the trustworthy_cutoff. \n\nThe number of bins N_rm bin in any binning level is related to  the number of elements N and its binning level ell in 0 1 dots  by \n\nN_rm bin = fracN2^ell\n\nThis means that, for a given trustworthy_cutoff of t_c, then the maximum number of trustworthy_levels present are \n\nrm Total(ell) = 1 + rm floor left log_2 left( fracNt_c right) right\n\nwhere the extra 1 comes from assuming the original data stream has more than t_c elements in it, making the ell = 0 level a trustworthy_level. \n\nnote: Note\nBasically this just means that the statistics we're showing are not susceptible to low-number effects. The log_2 term is the calculated  using max_trustworthy_level.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.update_SandT!-Tuple{LevelAccumulator}","page":"API Reference","title":"OnlineLogBinning.update_SandT!","text":"update_SandT!(lacc::LevelAccumulator)\n\nApply the Svalue and Tvalue formula to update lacc.Taccum and return the PairAccumulator Tvalue increment.\n\nAdditional information\n\nS must be updated before T since the former depends on the latter's history.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.update_num_bins!","page":"API Reference","title":"OnlineLogBinning.update_num_bins!","text":"update_num_bins!(lacc::LevelAccumulator, [incr = 2])\n\nIncrement the number of bins accumulated by incr.\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineLogBinning.var_of_mean-Tuple{BinningAccumulator}","page":"API Reference","title":"OnlineLogBinning.var_of_mean","text":"var_of_mean( bacc::BinningAccumulator; [level = 0] )\n\nOnline measurement of the [BinningAccumulator] variance of the mean.\n\nAdditional information\n\nThis quantity is considered online despite that it is not regularly updated when data is push!ed from the stream.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.var_of_mean-Tuple{LevelAccumulator}","page":"API Reference","title":"OnlineLogBinning.var_of_mean","text":"var_of_mean( lacc::LevelAccumulator ) = var(lacc) / lacc.num_bins\n\nOnline measurement of the [LevelAccumulator] variance of the mean.\n\nAdditional information\n\nThis quantity is considered online despite that it is not regularly updated when data is push!ed from the stream.\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.mean-Tuple{BinningAccumulator}","page":"API Reference","title":"Statistics.mean","text":"mean( bacc::BinningAccumulator; [level = 0] )\n\nOnline measurement of the [BinningAccumulator] mean.\n\nAdditional information\n\nThis quantity is considered online despite that it is not regularly updated when data is push!ed from the stream.\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.mean-Tuple{LevelAccumulator}","page":"API Reference","title":"Statistics.mean","text":"mean( lacc::LevelAccumulator )\n\nOnline measurement of the [LevelAccumulator] mean.\n\nAdditional information\n\nThis quantity is considered online despite that it is not regularly updated when data is push!ed from the stream.\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.std-Tuple{BinningAccumulator}","page":"API Reference","title":"Statistics.std","text":"std( bacc::BinningAccumulator )\n\nOnline measurement of the [BinningAccumulator] standard deviation.\n\nAdditional information\n\nThis quantity is considered online despite that it is not regularly updated when data is push!ed from the stream.\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.std-Tuple{LevelAccumulator}","page":"API Reference","title":"Statistics.std","text":"std( lacc::LevelAccumulator ) = sqrt(var(lacc))\n\nOnline measurement of the [LevelAccumulator] standard deviation.\n\nAdditional information\n\nThis quantity is considered online despite that it is not regularly updated when data is push!ed from the stream.\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.var-Tuple{BinningAccumulator}","page":"API Reference","title":"Statistics.var","text":"var( bacc::LevelAccumulator; [level = 0] )\n\nOnline measurement of the [BinningAccumulator] variance.\n\nAdditional information\n\nThis quantity is considered online despite that it is not regularly updated when data is push!ed from the stream.\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.var-Tuple{LevelAccumulator}","page":"API Reference","title":"Statistics.var","text":"var( lacc::LevelAccumulator )\n\nOnline measurement of the [LevelAccumulator] variance.\n\nAdditional information\n\nThis quantity is considered online despite that it is not regularly updated when data is push!ed from the stream.\n\n\n\n\n\n","category":"method"},{"location":"why_binning/","page":"Why use a Binning Analysis","title":"Why use a Binning Analysis","text":"DocTestSetup = quote using OnlineLogBinning end","category":"page"},{"location":"why_binning/#Why-use-a-Binning-Analysis?","page":"Why use a Binning Analysis","title":"Why use a Binning Analysis?","text":"","category":"section"},{"location":"why_binning/","page":"Why use a Binning Analysis","title":"Why use a Binning Analysis","text":"As described in Markus Wallerberger (2019), Vinay Ambegaokar, Matthias Troyer (2010), Tony F. Chan, Gene H. Golub, Randall J. LeVeque (1983), Carsten Bauer (2020), and James Gubernatis, Naoki Kawashima, Philipp Werner (2016), the presence of correlations in a data stream generated in Markov Chain Monte Carlo simulations renders any measures of error severely underestimated.","category":"page"},{"location":"why_binning/#Theoretical-background","page":"Why use a Binning Analysis","title":"Theoretical background","text":"","category":"section"},{"location":"why_binning/","page":"Why use a Binning Analysis","title":"Why use a Binning Analysis","text":"The naive approach is to calculate the mean and the variance of the mean, var_of_mean, for a given data stream X. For uncorrelated data, this becomes","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis","title":"Why use a Binning Analysis","text":"beginaligned\nmathttmean(X) = frac1M sum_i = 1^M x_i\n\nmathttvar_of_mean(X) = frac1M(M-1) sum_i = 1^M (x_i - mathttmean(X))^2\nendaligned","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis","title":"Why use a Binning Analysis","text":"Fortunately, in the presence of correlations, the mean doesn't change. Unfortunately, the var_of_mean does. Indeed, one can show that it's given by","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis","title":"Why use a Binning Analysis","text":"mathttvar_of_mean(X) = frac1 + 2tau_XM(M-1) sum_i = 1^M (x_i - mathttmean(X))^2","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis","title":"Why use a Binning Analysis","text":"where the as shown in the Figure within the Accumulator type hierarchy. Clearly, the uncorrelated var_of_mean is just increased by a factor of R_X equiv 1 + 2tau_X, where tau_X is defined as the integrated autocorrelation_time of the data stream. The binning analysis provides a fast as an O(N) method for calculating the autocorrelation_time. It's also cheap, only requiring O(log N) in RAM.  For those who are unfamiliar with the term, normally one would calculate tau_X by","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis","title":"Why use a Binning Analysis","text":"tau_X = sum_i = 1^M sum_i  j left x_ix_j - mathttmean(x)^2 right","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis","title":"Why use a Binning Analysis","text":"which is an  O(N^2) summation and can suffer from numerical instabilities.","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis","title":"Why use a Binning Analysis","text":"As one performs pairwise means in each binning level to construct the next highest, and then calculates the var_of_mean for each level, one can see that it rises and then eventually saturates around a particular plateau value. Normalizing by the original var_of_mean calculation assuming the data stream is uncorrelated, one can then calculate R_X in the ell^rm th binning level as","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis","title":"Why use a Binning Analysis","text":"R_X(ell) = fracmathttvar_of_mean(X^(ell))mathttvar_of_mean(X^(0)) = frac m^(ell) mathttvar(X^(ell))  mathttvar(X^(0)) ","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis","title":"Why use a Binning Analysis","text":"where var is the normal variance and m^(ell) is the bin size, or the number of original data values accumulated into a single data point at the ell^rm th level.","category":"page"},{"location":"why_binning/#Visualizing-a-Binning-Analysis","page":"Why use a Binning Analysis","title":"Visualizing a Binning Analysis","text":"","category":"section"},{"location":"why_binning/","page":"Why use a Binning Analysis","title":"Why use a Binning Analysis","text":"The final result of the binning analysis, for sufficiently long data streams, will be to see a sigmoid-like curve:","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis","title":"Why use a Binning Analysis","text":"using OnlineLogBinning, Plots, LaTeXStrings\nsignal = zeros(Float64, Int(2^18))\nread!( joinpath(\"assets\", \"telegraph_plateau.bin\"), signal)\nbacc = BinningAccumulator()\npush!(bacc, signal)\n\nall_levels = [lvl for lvl in 0:(bin_depth(bacc) - 1)]\nplt = plot( all_levels, RxValue(bacc, false)[1:(end - 1)];\n            label = \"Binning Analysis\", \n            xlabel = L\"Bin Level $\\ell$\",\n            ylabel = L\"$R_X(\\ell)$\",\n            markershape = :circle,\n            legend = :topleft )\n\nlevels = trustworthy_level(bacc)\nrxvalues = RxValue(bacc)\nfit = fit_RxValues( levels, rxvalues )\n\nplot!( plt, all_levels, sigmoid(all_levels, fit.param);\n       label = \"Sigmoid Fit\" )\n\nvline!( plt, [max_trustworthy_level(bacc[level = 0].num_bins)];\n        ls = :dash, color = \"gray\", label = \"Maximum Trustworthy Level\")\n\nsavefig(joinpath(\"assets\", \"plateau_plot.png\"))\n\nGC.gc()","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis","title":"Why use a Binning Analysis","text":"(Image: PlateauPlot)","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis","title":"Why use a Binning Analysis","text":"For insufficiently long data streams, we do not expect a plateau, as shown in the following case:","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis","title":"Why use a Binning Analysis","text":"using OnlineLogBinning, Plots, LaTeXStrings\nsignal = zeros(Float64, Int(2^10))\nread!( joinpath(\"assets\", \"telegraph_no_plateau.bin\"), signal)\nbacc = BinningAccumulator()\npush!(bacc, signal)\n\nall_levels = [lvl for lvl in 0:(bin_depth(bacc) - 1)]\nplt = plot( all_levels, RxValue(bacc, false)[1:(end - 1)];\n            label = \"Binning Analysis\", \n            xlabel = L\"Bin Level $\\ell$\",\n            ylabel = L\"$R_X(\\ell)$\",\n            markershape = :circle,\n            legend = :topleft )\n\nlevels = trustworthy_level(bacc)\nrxvalues = RxValue(bacc)\nfit = fit_RxValues( levels, rxvalues )\n\nplot!( plt, all_levels, sigmoid(all_levels, fit.param);\n       label = \"Sigmoid Fit\" )\n\nvline!( plt, [max_trustworthy_level(bacc[level = 0].num_bins)];\n        ls = :dash, color = \"gray\", label = \"Maximum Trustworthy Level\")\n\nsavefig(joinpath(\"assets\", \"no_plateau_plot.png\"))\n\nGC.gc()","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis","title":"Why use a Binning Analysis","text":"(Image: NoPlateauPlot)","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis","title":"Why use a Binning Analysis","text":"Indeed, we have actually chosen the sigmoid, as its inflection point is easily calculable. If the Maximum Trustworthy Level is less than the fitted inflection point, then our binning analysis says no plateau was found, and by default it returns the maximal value of R_X.","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis","title":"Why use a Binning Analysis","text":"DocTestSetup = nothing","category":"page"},{"location":"accumulators/#OnlineLogBinning's-Accumulator-structs","page":"Accumulator Hierarchy","title":"OnlineLogBinning's Accumulator structs","text":"","category":"section"},{"location":"accumulators/#The-[BinningAccumulator](@ref)","page":"Accumulator Hierarchy","title":"The BinningAccumulator","text":"","category":"section"},{"location":"accumulators/","page":"Accumulator Hierarchy","title":"Accumulator Hierarchy","text":"This is the main interface to the binning statistics of a given data stream. The user should basically only mess with this type of object. The binning analysis is performed using it and all important statistical quantities can be found from it.","category":"page"},{"location":"accumulators/","page":"Accumulator Hierarchy","title":"Accumulator Hierarchy","text":"A BinningAccumulator is a wrapper around a Vector of LevelAccumulators. For a given data stream of size N, there are rm floorlog_2(N) binning levels. The BinningAccumulator has a length which is one more than the total number of binning levels, where the bottom-most level, level = 0, represents the unbinned data.","category":"page"},{"location":"accumulators/#The-[LevelAccumulator](@ref)","page":"Accumulator Hierarchy","title":"The LevelAccumulator","text":"","category":"section"},{"location":"accumulators/","page":"Accumulator Hierarchy","title":"Accumulator Hierarchy","text":"This data structure keeps track of the online mean and variance for a given level. These accumulated values are only updated though after a pair from the data stream has been read in through the LevelAccumulator's PairAccumulator.","category":"page"},{"location":"accumulators/#The-[PairAccumulator](@ref)","page":"Accumulator Hierarchy","title":"The PairAccumulator","text":"","category":"section"},{"location":"accumulators/","page":"Accumulator Hierarchy","title":"Accumulator Hierarchy","text":"This is the outward-facing data structure to a given data stream. Once a pair from the data stream has been read, then the mean and variance accumulators are updated for a given level, and then the mean is propagated to the next binning level, where the process is repeated. This implements the logarithmic binning analysis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = quote using OnlineLogBinning end","category":"page"},{"location":"#OnlineLogBinning","page":"Home","title":"OnlineLogBinning","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Dev) (Image: Build Status)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia package to determine effective number of uncorrelated data points in a correlated data stream via an O(log N) online binning algorithm.","category":"page"},{"location":"#Accumulator-type-hierarchy","page":"Home","title":"Accumulator type hierarchy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: BinningAccumulatorDiagram)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We implement this with three nested Accumulator structs: the outermost BinningAccumulator, the middle-level LevelAccumulator, and the innermost PairAccumulator. The BinningAccumulator stores a Vector of LevelAccumulator, each of which store their own PairAccumulator.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nFor more information, check out OnlineLogBinning's Accumulator structs.","category":"page"},{"location":"#Similar-packages","page":"Home","title":"Similar packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BinningAnalysis.jl for a very similar Julia package which served as an inspiration for this one. Our package does not have as broad of a scope as theirs.\nOne of the authors of BinningAnalysis.jl also wrote Ref. Carsten Bauer (2020) which gives a great introduction to the statistical analysis of Monte Carlo data.\nOnlineStats.jl for many more online statistics and routines, most of which are beyond the scope of this package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = nothing","category":"page"},{"location":"math/#The-Math-Behind-OnlineLogBinning","page":"Mathematical Details","title":"The Math Behind OnlineLogBinning","text":"","category":"section"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"The online binning functionality works by combining the method described in Section D of Markus Wallerberger (2019), as well as in the Dicussion of Vinay Ambegaokar, Matthias Troyer (2010), where one keeps track of several accumulators, with the first-pass pairwise algorithm from Tony F. Chan, Gene H. Golub, Randall J. LeVeque (1983). The online (i.e. O(1)) quantities that are obtained from this process are the Tvalue, T, and Svalue, S, from Tony F. Chan, Gene H. Golub, Randall J. LeVeque (1983), representing the total accumulator and square accumulator, respectively, as well as the total number of bins m. Together, these online quantities can be combined at any point to yield other (technically) online statistics like the mean or variance. These statistics are online in the sense that they are simple function of online accumulators, and so we emphasize their calculation is still amortized with complexity O(1). This is despite that the mean, variance, etc. are not updated continuously; only m, T, and S are.","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"Using the notation of Ref. Tony F. Chan, Gene H. Golub, Randall J. LeVeque (1983), the T and S calculated in a data stream comprised of a sequence of m elements,","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"x_k in leftlbrace x_1x_2dotsx_mrightrbrace","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"is given by","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"T_1m = sum_k = 1^m x_k","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"S_1m = sum_k = 1^m left(x_k - barx right)^2","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"where the mean is given by","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"barx = fracT_1mm","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"The variance is then given by","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"sigma^2 = fracS_1mm-1","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"These two quantities can be computed online with the first-pass pairwise algorithm given an additional two elements leftlbrace x_m+1 x_m+2 rightrbrace using the following expressions:","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"T_1m + 2 = T_1m + T_m+1m+2","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"S_1m + 2 = S_1 m + S_m+1 m+2 + fracm2(m+2) left( frac2m T_1m - T_m+1m+2 right)^2","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"where","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"T_m+1m+2 = x_m+1 + x_m+2","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"S_m+1 m+2 = frac12left(x_m+2 - x_m+1 right)^2","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"We implement this with three nested Accumulator structs: the outermost BinningAccumulator, the middle-level LevelAccumulator, and the innermost PairAccumulator. The BinningAccumulator stores a Vector of LevelAccumulators, each of which store their own PairAccumulator.","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"The PairAccumulator struct is the outward facing element of the BinningAccumulator in that it takes in data directly from the data stream. After a pair of values has been imported from the stream, then leftlbrace T_m+1m+2 S_m+1m+2 rightrbrace are computed and exported to the encapsulating LevelAccumulator, where the leftlbrace m T_1m S_1m rightrbrace accumulator values are stored. Then, the PairAccumulator is reset!. At the same time, the outermost BinningAccumulator passes the T_m+1m+2  2 (ie the pairwise mean) value onto the PairAccumulator in the LevelAccumulator at the next binning level, where the whole process is repeated again, except the accumulated T_1m+2  2 values comprise the new data stream.","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"The fact that the data stream is processed in pairs before being passed along to the other binning levels inherently leads to a bin_depth given by rm floorleftlog_2 (m)right, which is the total number of binning levels in the data stream.","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"DocTestSetup = quote using OnlineLogBinning end","category":"page"},{"location":"example/#How-to-use-OnlineLogBinning","page":"Example Usage","title":"How to use OnlineLogBinning","text":"","category":"section"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"First, construct an empty [BinningAccumulator] with of T <: Number parametric type. Let's take the default T = Float64 as an example.","category":"page"},{"location":"example/#Initialization","page":"Example Usage","title":"Initialization","text":"","category":"section"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"To start, initialize a BinningAccumulator{T}:","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"julia> bacc = BinningAccumulator()\nBinningAccumulator{Float64} with 0 binning levels.\n0th Binning Level (unbinned data):\nLevelAccumulator{Float64} with online fields:\n    level    = 0\n    num_bins = 0\n    Taccum   = 0.0\n    Saccum   = 0.0\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = NaN\n    Current Variance         = -0.0\n    Current Std. Deviation   = -0.0\n    Current Var. of the Mean = NaN\n    Current Std. Error       = NaN","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"note: Note\nWe currently only support Float types, i.e. T <: AbstractFloat or T is a Complex{Float#}. The tested types are listed in OLB_tested_numbers.","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"Then, push! either a single value or a data stream (sequence of values of itr type) to the BinningAccumulator. The online analysis will be taken care of automatically.","category":"page"},{"location":"example/#Accumulate-data","page":"Example Usage","title":"Accumulate data","text":"","category":"section"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"The easiest way to accumulate data from a data stream is by push!ing a single value into the BinningAccumulator.","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"julia> push!(bacc, 1)\nBinningAccumulator{Float64} with 0 binning levels.\n0th Binning Level (unbinned data):\nLevelAccumulator{Float64} with online fields:\n    level    = 0\n    num_bins = 0\n    Taccum   = 0.0\n    Saccum   = 0.0\n    Paccum   = PairAccumulator{Float64}(false, [0.0, 1.0])\n\n    Calculated Level Statistics:\n    Current Mean             = NaN\n    Current Variance         = -0.0\n    Current Std. Deviation   = -0.0\n    Current Var. of the Mean = NaN\n    Current Std. Error       = NaN\n","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"note: Note\nValues of incorrect type are converted to the correct type internally.","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"Additionally, one can push! a data stream into the BinningAccumulator:","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"julia> push!(bacc, [1, 2, 3, 4, 3, 2, 1])\nBinningAccumulator{Float64} with 3 binning levels.\n0th Binning Level (unbinned data):\nLevelAccumulator{Float64} with online fields:\n    level    = 0\n    num_bins = 8\n    Taccum   = 17.0\n    Saccum   = 8.875\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = 2.125\n    Current Variance         = 1.2678571428571428\n    Current Std. Deviation   = 1.1259916264596033\n    Current Var. of the Mean = 0.15848214285714285\n    Current Std. Error       = 0.3980981573144277\n\n1th Binning Level:\nLevelAccumulator{Float64} with online fields:\n    level    = 1\n    num_bins = 4\n    Taccum   = 8.5\n    Saccum   = 3.6875\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = 2.125\n    Current Variance         = 1.2291666666666667\n    Current Std. Deviation   = 1.1086778913041726\n    Current Var. of the Mean = 0.3072916666666667\n    Current Std. Error       = 0.5543389456520863\n\n2th Binning Level:\nLevelAccumulator{Float64} with online fields:\n    level    = 2\n    num_bins = 2\n    Taccum   = 4.25\n    Saccum   = 0.28125\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = 2.125\n    Current Variance         = 0.28125\n    Current Std. Deviation   = 0.5303300858899106\n    Current Var. of the Mean = 0.140625\n    Current Std. Error       = 0.375\n\n3th Binning Level:\nLevelAccumulator{Float64} with online fields:\n    level    = 3\n    num_bins = 0\n    Taccum   = 0.0\n    Saccum   = 0.0\n    Paccum   = PairAccumulator{Float64}(false, [0.0, 2.125])\n\n    Calculated Level Statistics:\n    Current Mean             = NaN\n    Current Variance         = -0.0\n    Current Std. Deviation   = -0.0\n    Current Var. of the Mean = NaN\n    Current Std. Error       = NaN","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"note: Note\nThe highest binning level will typically yield useless NaN statistics, but that just reflects the fact that the num_bins, Taccum, and Saccum accumulators are only updated once the level's PairAccumulator is full.","category":"page"},{"location":"example/#Available-online-statistics","page":"Example Usage","title":"Available online statistics","text":"","category":"section"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"One can then calculate the following statistics from the BinningAccumulator at any binning level = lvl:","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"mean(bacc::BinningAccumulator; level = lvl)           # arithmetic mean\nvar(bacc::BinningAccumulator; level = lvl)            # sample variance \nstd(bacc::BinningAccumulator; level = lvl)            # sample standard deviation \nvar_of_mean(bacc::BinningAccumulator; level = lvl)    # variance of the mean \nstd_error(bacc::BinningAccumulator; level = lvl)      # standard error of the mean ","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"The binning level is optional. By default, the binning level is set to level = 0. This level, accessed by bacc[level = 0], represents the unbinnned statistics from of the original data stream. The LevelAccumulators from any binning level can also be extracted using the overloaded [] notation as","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"julia> bacc[level = 0]\nLevelAccumulator{Float64} with online fields:\n    level    = 0\n    num_bins = 8\n    Taccum   = 17.0\n    Saccum   = 8.875\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = 2.125\n    Current Variance         = 1.2678571428571428\n    Current Std. Deviation   = 1.1259916264596033\n    Current Var. of the Mean = 0.15848214285714285\n    Current Std. Error       = 0.3980981573144277\n\njulia> bacc[level = 1]\nLevelAccumulator{Float64} with online fields:\n    level    = 1\n    num_bins = 4\n    Taccum   = 8.5\n    Saccum   = 3.6875\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = 2.125\n    Current Variance         = 1.2291666666666667\n    Current Std. Deviation   = 1.1086778913041726\n    Current Var. of the Mean = 0.3072916666666667\n    Current Std. Error       = 0.5543389456520863","category":"page"},{"location":"example/#Perform-a-binning-analysis","page":"Example Usage","title":"Perform a binning analysis","text":"","category":"section"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"Once a sufficient amount of data has been binned, one can employ the BinningAnalysis routines found in BinningAnalysis.jl. To show how this works, we make use of a pre-prepared random telegraph signal generated with the TelegraphNoise.jl package. The signal is stored as a binary file in docs/src/assets.","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"The simplest one to use is fit_RxValues that takes in a single required BinningAccumulator as an argument.","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"julia> signal = zeros(Float64, Int(2^18));\n\njulia> read!( joinpath(\"src\", \"assets\", \"telegraph_plateau.bin\"), signal);\n\njulia> bacc = BinningAccumulator();\n\njulia> push!(bacc, signal);\n\njulia> result = fit_RxValues(bacc)\nBinning Analysis Result:\n    Plateau Present:   true\n    Fitted Rx Plateau: 14.611315366634937","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"The Plateau Present flag indicates whether a sigmoid fit to the RxValues is reasonable so as to take its plateau seriously. (See _plateau_found for details.) The value of the fitted plateau is also returned. If Plateau Present == false, then the plateau is set to be the size of the data stream. This is because the effective number of uncorrelated values in the data stream of size M is given by M_rm eff = M  R_X.","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"Other quantities can be extracted from the BinningAnalysisResult, for example, the autocorrelation_time and the effective_uncorrelated_values in the data stream.","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"julia> autocorrelation_time(result)\n6.8056576833174685\n\njulia> effective_uncorrelated_values(length(signal), result)\n17941","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"DocTestSetup = nothing","category":"page"}]
}
