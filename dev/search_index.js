var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"CurrentModule = OnlineLogBinning","category":"page"},{"location":"api/#OnlineLogBinning-API-Reference","page":"API Reference","title":"OnlineLogBinning API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Documentation for OnlineLogBinning.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [OnlineLogBinning]","category":"page"},{"location":"api/#OnlineLogBinning.MINIMUM_VAR_64","page":"API Reference","title":"OnlineLogBinning.MINIMUM_VAR_64","text":"const MINIMUM_RX_64 = eps(Float64)\nconst MINIMUM_RX_32 = eps(Float32) \nconst MINIMUM_RX_16 = eps(Float16)\n\nMinimum allowable variance values based on the least-squares fit type. Any data stream variances smaller than these are suspiciously small, and one should not trust an automated binning analysis in these instances.\n\n\n\n\n\n","category":"constant"},{"location":"api/#OnlineLogBinning.OLB_tested_numbers","page":"API Reference","title":"OnlineLogBinning.OLB_tested_numbers","text":"OLB_tested_numbers\n\nDefines the list of tested numerical types for OnlineLogBinning.jl.\n\nnote: Note\nThese types are specifically given as: Float16, Float32, Float64 for Real numbers.\nComplexF16, ComplexF32, ComplexF64 for Complex numbers.\n\n\n\n\n\n","category":"constant"},{"location":"api/#OnlineLogBinning.TRUSTING_CUTOFF","page":"API Reference","title":"OnlineLogBinning.TRUSTING_CUTOFF","text":"TRUSTING_CUTOFF = 128\n\nThe minimum number of bins required for any given binning level to be considered statistically trustworthy so as to minimally suffer from small-number fluctuations.\n\nnote: Note\nThis is value is similar to what's given in Carsten Bauer (2020) and four times greater than what's  in James Gubernatis, Naoki Kawashima, Philipp Werner (2016).\n\n\n\n\n\n","category":"constant"},{"location":"api/#OnlineLogBinning.BinningAccumulator","page":"API Reference","title":"OnlineLogBinning.BinningAccumulator","text":"BinningAccumulator{T}() where {T <: Number} (default T = Float64)\nBinningAccumulator{T}(::Vector{LevelAccumulator{T}})\nBinningAccumulator{T}(::Int) where {T <: Number} (default T = Float64)\n\nMain data structure for the binning analysis. T == Float64 by default in the empty constructor. There are three constructors, an empty one, one that copy-constructs with a Vector of LevelAccumulators, and one that pre-allocates that Vector based on an anticipated datastream size.\n\nContents\n\nLvlAccums::Vector{LevelAccumulator{T}}\nA wrapper around the LevelAccumulators from each binning level\n\ncompat: Compat\nThe pre-allocated constructor requires at least version 0.2.2.\n\nExample\n\njulia> # Create a BinningAccumulator with the default type T == Float64\n\njulia> bacc = BinningAccumulator()  \nBinningAccumulator{Float64} with 0 binning levels.\n0th Binning Level (unbinned data):\nLevelAccumulator{Float64} with online fields:\n    level    = 0\n    num_bins = 0\n    Taccum   = 0.0\n    Saccum   = 0.0\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = NaN\n    Current Variance         = -0.0\n    Current Std. Deviation   = -0.0\n    Current Var. of the Mean = NaN\n    Current Std. Error       = NaN\n\njulia> # Add a data stream using the push! function\n\njulia> # (The data stream does not have to have a length == power of 2.)\n\njulia> push!(bacc, [1, 2, 3, 4])\nBinningAccumulator{Float64} with 2 binning levels.\n0th Binning Level (unbinned data):\nLevelAccumulator{Float64} with online fields:\n    level    = 0\n    num_bins = 4\n    Taccum   = 10.0\n    Saccum   = 5.0\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = 2.5\n    Current Variance         = 1.6666666666666667\n    Current Std. Deviation   = 1.2909944487358056\n    Current Var. of the Mean = 0.4166666666666667\n    Current Std. Error       = 0.6454972243679028\n\n1th Binning Level:\nLevelAccumulator{Float64} with online fields:\n    level    = 1\n    num_bins = 2\n    Taccum   = 5.0\n    Saccum   = 2.0\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = 2.5\n    Current Variance         = 2.0\n    Current Std. Deviation   = 1.4142135623730951\n    Current Var. of the Mean = 1.0\n    Current Std. Error       = 1.0\n\n2th Binning Level:\nLevelAccumulator{Float64} with online fields:\n    level    = 2\n    num_bins = 0\n    Taccum   = 0.0\n    Saccum   = 0.0\n    Paccum   = PairAccumulator{Float64}(false, [0.0, 2.5])\n\n    Calculated Level Statistics:\n    Current Mean             = NaN\n    Current Variance         = -0.0\n    Current Std. Deviation   = -0.0\n    Current Var. of the Mean = NaN\n    Current Std. Error       = NaN\n\n\n\n\n\n\n","category":"type"},{"location":"api/#OnlineLogBinning.BinningAnalysisResult","page":"API Reference","title":"OnlineLogBinning.BinningAnalysisResult","text":"BinningAnalysisResult{T <: AbstractFloat}\n\nSmall struct to determine if there is a _plateau_found from a BinningAccumulator, and what its value is.\n\nContents\n\nplateau_found::Bool: whether the fit_RxValues found a plateau from the binned data.\nRxAmplitude::T: the value for the plateau as calculated by fit_RxValues.\nIf plateau_found == false, then RxAmplitude = length(X) for a datastream X, so as to maximize the error estimation.\neffective_length::Int: the effective number of uncorrelated data points in the datastream X as calculated by \n\nm_rm eff = mathttfloor left( fracmathttlength(X)R_X right)\n\nbinning_mean::T: the value of the mean as calculated by \n\nmathttmean(X) = frac T^(0)  m^(0) \n\nbinning_error::T: the value of the error as calculated by \n\nbeginaligned\nmathtterror(X) = sqrt frac S^(0)  m_rm eff left( m^(0) - 1 right)  \n\n= sqrt left mathttfloorleft( fracm^(0)R_X right) right^-1  frac S^(0)  m^(0) - 1  \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"api/#OnlineLogBinning.LevelAccumulator","page":"API Reference","title":"OnlineLogBinning.LevelAccumulator","text":"LevelAccumulator{T <: Number}\n\nAccumulator structure for a given binning level.\n\nContents\n\nlevel::Int\nRegisters the binning level this accumulator is assigned\nnum_bins::Int \nHow many elements (i.e. bins) have been added to this accumulator\nTaccum::T\nStands for Total Accumulator.\nThis represents the T accumulator for the mean: mean ≡ T / num_bins.\nSaccum::T\nStands for Square Accumulator.\nThis represents the S accumulator for the variance: var ≡ S/(num_bins - 1).\nPaccum::PairAccumulator{T}\nAn outward facing PairAccumulator to meet incoming data streams. \nThis accumulator processes the incoming data and then exports the Tvalue and Svalue into updates for Taccum and Saccum, respectively.\n\n\n\n\n\n","category":"type"},{"location":"api/#OnlineLogBinning.PairAccumulator","page":"API Reference","title":"OnlineLogBinning.PairAccumulator","text":"PairAccumulator{T <: Number}\n\nAccumulator that directly faces an incoming data stream. Two values from that stream enter and are processed into the exported values of Tvalue and Svalue.\n\nContents\n\nfullpair::Bool\nA Boolean to keep track of which element of the pair is being accessed. Additionally, when fullpair == true then the contents are exported.\nvalues::MVector{2, T}\nThe individual values taken from the data stream to be processed. Both Tvalue and Svalue rely on them being accessible.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.eltype-Union{Tuple{BinningAccumulator{T}}, Tuple{T}} where T","page":"API Reference","title":"Base.eltype","text":"eltype(::BinningAccumulator{T}) → T\n\nReturns the type parameter for the BinningAccumulator.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{BinningAccumulator}","page":"API Reference","title":"Base.getindex","text":"getindex(bacc::BinningAccumulator; level)\n\nOverload the [] notation by accessing the BinningAccumulator's LvlAccums at a specific binning level keyword.\n\nExample\n\njulia> bacc = BinningAccumulator();\n\njulia> bacc[level = 0]\nLevelAccumulator{Float64} with online fields:\n    level    = 0\n    num_bins = 0\n    Taccum   = 0.0\n    Saccum   = 0.0\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = NaN\n    Current Variance         = -0.0\n    Current Std. Deviation   = -0.0\n    Current Var. of the Mean = NaN\n    Current Std. Error       = NaN\n\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{BinningAccumulator}","page":"API Reference","title":"Base.length","text":"length(bacc::BinningAccumulator)\n\nReturn the number of LevelAccumulators there are.\n\nExample\n\njulia> bacc = BinningAccumulator();\n\njulia> push!(bacc, [1, 2, 3, 4, 3, 2, 1]); # Data stream with 7 elements\n\njulia> length(bacc) # Only 2 binning levels (1 for unbinned data)\n3\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.push!-Tuple{BinningAccumulator, Any}","page":"API Reference","title":"Base.push!","text":"push!(bacc::BinningAccumulator, itr)\n\npush! each value of the data stream itr through the BinningAccumulator.\n\nExample\n\njulia> bacc = BinningAccumulator()\nBinningAccumulator{Float64} with 0 binning levels.\n0th Binning Level (unbinned data):\nLevelAccumulator{Float64} with online fields:\n    level    = 0\n    num_bins = 0\n    Taccum   = 0.0\n    Saccum   = 0.0\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = NaN\n    Current Variance         = -0.0\n    Current Std. Deviation   = -0.0\n    Current Var. of the Mean = NaN\n    Current Std. Error       = NaN\n\njulia> push!(bacc, [42, -26])\nBinningAccumulator{Float64} with 1 binning levels.\n0th Binning Level (unbinned data):\nLevelAccumulator{Float64} with online fields:\n    level    = 0\n    num_bins = 2\n    Taccum   = 16.0\n    Saccum   = 2312.0\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = 8.0\n    Current Variance         = 2312.0\n    Current Std. Deviation   = 48.08326112068523\n    Current Var. of the Mean = 1156.0\n    Current Std. Error       = 34.0\n\n1th Binning Level:\nLevelAccumulator{Float64} with online fields:\n    level    = 1\n    num_bins = 0\n    Taccum   = 0.0\n    Saccum   = 0.0\n    Paccum   = PairAccumulator{Float64}(false, [0.0, 8.0])\n\n    Calculated Level Statistics:\n    Current Mean             = NaN\n    Current Variance         = -0.0\n    Current Std. Deviation   = -0.0\n    Current Var. of the Mean = NaN\n    Current Std. Error       = NaN\n\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.push!-Tuple{BinningAccumulator, Number}","page":"API Reference","title":"Base.push!","text":"push!(bacc::BinningAccumulator, value::Number)\n\nAdd a single value from the data stream into the online binning analysis. The single value enters at the bin at the lowest level. \n\nExample\n\njulia> bacc = BinningAccumulator()\nBinningAccumulator{Float64} with 0 binning levels.\n0th Binning Level (unbinned data):\nLevelAccumulator{Float64} with online fields:\n    level    = 0\n    num_bins = 0\n    Taccum   = 0.0\n    Saccum   = 0.0\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = NaN\n    Current Variance         = -0.0\n    Current Std. Deviation   = -0.0\n    Current Var. of the Mean = NaN\n    Current Std. Error       = NaN\n\njulia> push!(bacc, 42)\nBinningAccumulator{Float64} with 0 binning levels.\n0th Binning Level (unbinned data):\nLevelAccumulator{Float64} with online fields:\n    level    = 0\n    num_bins = 0\n    Taccum   = 0.0\n    Saccum   = 0.0\n    Paccum   = PairAccumulator{Float64}(false, [0.0, 42.0])        \n\n    Calculated Level Statistics:\n    Current Mean             = NaN\n    Current Variance         = -0.0\n    Current Std. Deviation   = -0.0\n    Current Var. of the Mean = NaN\n    Current Std. Error       = NaN\n\n\nnote: Note\nNotice that the Taccum and Saccum remain zero while num_bins == 0.  These are only accumulated for each input pair. Or once Paccum.fullpair == true.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.push!-Tuple{PairAccumulator, Number}","page":"API Reference","title":"Base.push!","text":"push!(pacc::PairAccumulator, value::Number)\n\nOverload Base.push! for a PairAccumulator. One can only  push! a single value <: Number at a time into this type of accumulator.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.show-Tuple{IO, BinningAccumulator}","page":"API Reference","title":"Base.show","text":"show([io::IO = stdout], bacc::BinningAccumulator)\n\nOverload the Base.show function for human-readable displays.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.show-Tuple{IO, LevelAccumulator}","page":"API Reference","title":"Base.show","text":"show([io = stdout], lacc::LevelAccumulator)\n\nOverload Base.show for human-readable displays.\n\n\n\n\n\n","category":"method"},{"location":"api/#Measurements.measurement-Tuple{BinningAnalysisResult}","page":"API Reference","title":"Measurements.measurement","text":"measurement(::BinningAnalysisResult)\n\nConvert a BinningAnalysisResult into a  Measurements.jl measurement.\n\ncompat: Compat\nThis functionality requires at least v0.4.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.RxValue","page":"API Reference","title":"OnlineLogBinning.RxValue","text":"RxValue(bacc::BinningAccumulator, [trustworthy_only = true]; [trusting_cutoff])\n\nCalculate the RxValues from the statistically trustworthy binning levels by default, or from all of them if trustworthy_only == false. \n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineLogBinning.RxValue-Tuple{BinningAccumulator, Int64}","page":"API Reference","title":"OnlineLogBinning.RxValue","text":"RxValue(bacc::BinningAccumulator, level)\n\nCompute the R_X quantity from the binning analysis. This quantity starts at 1 for low binning levels, then gradually rises, until the  bins become statistically uncorrelated at which point R_X should saturate. Once saturated, the effective number of uncorrelated elements in a correlated  data stream of size M is given in terms of R_X by M  R_X. \n\nnote: Note\nSee Carsten Bauer (2020) and James Gubernatis, Naoki Kawashima, Philipp Werner (2016) for details.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.Svalue-Tuple{LevelAccumulator, Any, Any}","page":"API Reference","title":"OnlineLogBinning.Svalue","text":"Svalue(lacc::LevelAccumulator)\n\nFunction to calculate the online S_1m+2 summation as:\n\nS_1m+2 = S_1m + S_m+1m+2 + fracm2(m+2)left( frac2m T_1m - T_m+1m+2 right)^2\n\nwhere T_m+1m+2 is the pairwise Tvalue for the PairAccumulator.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.Svalue-Tuple{PairAccumulator}","page":"API Reference","title":"OnlineLogBinning.Svalue","text":"Svalue(pacc::PairAccumulator)\n\nThe S function for a single pair following the accumulation of m data points follows as \n\nbeginaligned\nS_m+1 m+2 equiv sum_k = m+1^m+2 left( x_k - frac12 T_m+1m+2 right)^2\n\n= frac12left( x_m+2 - x_m+1 right)^2\nendaligned\n\nThus, S_m+1m+2 does not need to take T_m+1m+2 as an argument.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.Tvalue-Tuple{LevelAccumulator, Any}","page":"API Reference","title":"OnlineLogBinning.Tvalue","text":"Tvalue(lacc::LevelAccumulator)\n\nFunction to calculate the online T_1m+2 summation as:\n\nT_1m+2 = T_1m + T_m+1m+2\n\nwhere T_m+1m+2 is the pairwise Tvalue for the PairAccumulator.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.Tvalue-Tuple{PairAccumulator}","page":"API Reference","title":"OnlineLogBinning.Tvalue","text":"Tvalue(pacc::PairAccumulator)\n\nThe T function for a single pair following the accumulation of m data points follows as \n\nT_m+1 m+2 equiv sum_k = m+1^m+2 x_k = x_m+1 + x_m+2\n\nas expected.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning._binning_index_to_findex-Tuple{Any}","page":"API Reference","title":"OnlineLogBinning._binning_index_to_findex","text":"_binning_index_to_findex(level)\n\nConvert the binning_index ∈ {0, 1, ... } to a (Fortran) findex ∈ {1, 2, ... }.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning._plateau_found-Tuple{BinningAccumulator, Any}","page":"API Reference","title":"OnlineLogBinning._plateau_found","text":"_plateau_found(bacc, fit) → Bool\n\nTest whether a plateau has been found from the fit using the LsqFit.jl package. This includes finding reasonable values for the sigmoid parameters.\n\nnote: Note\nWhat counts as a plateau?A plateau in the RxValues is defined to be present if the following three conditions on the sigmoid fit are all true:None of the computed level variances are too small. \nThe amplitude is positive.\nThe inflection point given by θ₁ / θ₂ < max_trustworthy_level(levels).If any of these conditions are violated, then we do not trust that the RxValues have actually converged to a single value, meaning that the datastream is not sufficiently large enough to separate correlated data from one another.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.autocorrelation_time-Tuple{Any}","page":"API Reference","title":"OnlineLogBinning.autocorrelation_time","text":"autocorrelation_time(RxVal)\n\nCalculation of the autocorrelation time tau_X = frac12left( R_X - 1 right).\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.bin_depth-Tuple{BinningAccumulator}","page":"API Reference","title":"OnlineLogBinning.bin_depth","text":"bin_depth(bacc::BinningAccumulator)\n\nNumber of binned levels present. length of the [BinningAccumulator] minus 1.\n\nExample\n\njulia> bacc = BinningAccumulator();\n\njulia> push!(bacc, [1, 2, 3, 4, 3, 2, 1]); # Data stream with 7 elements\n\njulia> bin_depth(bacc) # Only 2 binning levels (1 for unbinned data)\n2\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.binning_level-Tuple{Int64}","page":"API Reference","title":"OnlineLogBinning.binning_level","text":"binning_level(index::Int)\n\nConversion from LvlAccums index to binning_level.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.effective_uncorrelated_values-Tuple{Any, Real}","page":"API Reference","title":"OnlineLogBinning.effective_uncorrelated_values","text":"effective_uncorrelated_values(mvals, RxVal)\n\nCalculation of the effective number of uncorrelated values in a correlated datastream: \n\nm_rm eff =  mathttfloor left( frac m^(0) R_X right)\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.fit_RxValues","page":"API Reference","title":"OnlineLogBinning.fit_RxValues","text":"fit_RxValues(bacc::BinningAccumulator, [p0])\n\nUse LsqFit.jl to fit a sigmoid to a BinningAccumulator. Note, only statistically trustworthy binning levels are used. This function returns a BinningAnalysisResult struct.\n\nAdditional information\n\nThe default arguments passed take on the following values:\n\nInitial guess for sigmoid parameters: p0 = [1, 0, 1].\nSee BinningAnalysisResult for a description of how each fieldname is computed.\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineLogBinning.fit_RxValues-2","page":"API Reference","title":"OnlineLogBinning.fit_RxValues","text":"fit_RxValues(levels, rxvalues, [p0])\n\nUse LsqFit.jl to fit a sigmoid to a set of RxValues generated by a BinningAccumulator.\n\nAdditional information\n\nThe default arguments passed take on the following values:\n\nInitial guess for sigmoid parameters: p0 = [1, 0, 1].\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineLogBinning.levels_RxValues","page":"API Reference","title":"OnlineLogBinning.levels_RxValues","text":"levels_RxValues(bacc::BinningAccumulator, [trustworthy_only = true]; [trusting_cutoff = TRUSTING_CUTOFF])\n\nReturn a Tuple of identically-sized Vectors. The first element of the Tuple are the binning levels  and the second are the corresonding RxValues. If trustworthy_only == true, then only the  trustworthy levels and values are returned. If trustworthy_only == false, then all levels and values are returned (except for the last level which is typically not full).\n\nThis function is meant to make visualization more convenient and does not offer any different functionality than what was available before.\n\ncompat: Compat\nRequires OnlineLogBinning.jl v0.3.0 or higher.\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineLogBinning.max_trustworthy_level-Tuple{Any}","page":"API Reference","title":"OnlineLogBinning.max_trustworthy_level","text":"max_trustworthy_level(nelements; [trusting_cutoff])\n\nCalculates the highest binning level that remains statistically trustworthy according to the TRUSTING_CUTOFF, t_c. \n\nGiven a number of elements in a data stream, N, this quantity is \n\nell_rm max = rm floor left log_2 left( fracNt_c right) right\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.reset!-Union{Tuple{BinningAccumulator{T}}, Tuple{T}} where T","page":"API Reference","title":"OnlineLogBinning.reset!","text":"reset!(bacc::BinningAccumulator{T})\n\nReset the BinningAccumulator by reconstruction.\n\nAdditional information\n\nWhile this is not a literal reset per se, with a large enough BinningAccumulator it will be certainly faster just to blow up the old one (in memory) and start over.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.reset!-Union{Tuple{PairAccumulator{T}}, Tuple{T}} where T","page":"API Reference","title":"OnlineLogBinning.reset!","text":"reset!(pacc::PairAccumulator)\n\nReturn the PairAccumulator to its initial state. Presumably one just exported the  Tvalue and Svalue from it before the reset!.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.sigmoid","page":"API Reference","title":"OnlineLogBinning.sigmoid","text":"sigmoid(x, [amp = 1], [θ₁ = 0], [θ₂ = 1])\n\nCalculate a Sigmoid at a given argument x. The Sigmoid function S(x A theta_1 theta_2) is of the form\n\nS(x A theta_1 theta_2) = fracA1 + expleft( theta_1 - theta_2 x right)\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineLogBinning.sigmoid-Tuple{AbstractVecOrMat, Any}","page":"API Reference","title":"OnlineLogBinning.sigmoid","text":"sigmoid(x, pvals) = sigmoid(x, pvals...)\n\nVectorized sigmoid function.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.sigmoid_jacobian-Tuple{AbstractVecOrMat, Any}","page":"API Reference","title":"OnlineLogBinning.sigmoid_jacobian","text":"sigmoid_jacobian(x, pvals)\n\nCalculate the \"Jacobian\" of first derivatives for a sigmoid to speed the LsqFit fitting. The derivatives are given by \n\nbeginaligned\nfracpartial Spartial A = frac11 + expleft( theta_1 - theta_2 x right)\n\n\n\nfracpartial Spartial theta_1 = -fracA  expleft( theta_1 - theta_2 x right) left 1 + expleft( theta_1 - theta_2 x right) right^2\n\n\n\nfracpartial Spartial theta_2 = fracA  x  expleft( theta_1 - theta_2 x right) left 1 + expleft( theta_1 - theta_2 x right) right^2\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.std_error-Tuple{BinningAccumulator}","page":"API Reference","title":"OnlineLogBinning.std_error","text":"std_error( bacc::BinningAccumulator )\n\nOnline measurement of the [BinningAccumulator] standard error.\n\nAdditional information\n\nThis quantity is considered online despite that it is not regularly updated when data is push!ed from the stream.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.std_error-Tuple{LevelAccumulator}","page":"API Reference","title":"OnlineLogBinning.std_error","text":"std_error( lacc::LevelAccumulator ) = sqrt(var_of_mean(lacc))\n\nOnline measurement of the [LevelAccumulator] standard error.\n\nAdditional information\n\nThis quantity is considered online despite that it is not regularly updated when data is push!ed from the stream.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.trustworthy_indices-Tuple{BinningAccumulator}","page":"API Reference","title":"OnlineLogBinning.trustworthy_indices","text":"trustworthy_indices(bacc::BinningAccumulator; [trusting_cutoff])\n\nReturn the (Fortran) indices 1, 2, 3, ... corresponding to trustworthy_levels.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.trustworthy_level-Tuple{Any, Any}","page":"API Reference","title":"OnlineLogBinning.trustworthy_level","text":"trustworthy_level(level; [trustworthy_cutoff = 64])\n\nA binning level is said to be a trustworthy_level if the number of bins it contains is greater than or equal to the trustworthy_cutoff. \n\nThe number of bins N_rm bin in any binning level is related to  the number of elements N and its binning level ell in 0 1 dots  by \n\nN_rm bin = fracN2^ell\n\nThis means that, for a given trustworthy_cutoff of t_c, then the maximum number of trustworthy_levels present are \n\nrm Total(ell) = 1 + rm floor left log_2 left( fracNt_c right) right\n\nwhere the extra 1 comes from assuming the original data stream has more than t_c elements in it, making the ell = 0 level a trustworthy_level. \n\nnote: Note\nBasically this just means that the statistics we're showing are not susceptible to low-number effects. The log_2 term is the calculated  using max_trustworthy_level.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.update_SandT!-Tuple{LevelAccumulator}","page":"API Reference","title":"OnlineLogBinning.update_SandT!","text":"update_SandT!(lacc::LevelAccumulator)\n\nApply the Svalue and Tvalue formula to update lacc.Taccum and return the PairAccumulator Tvalue increment.\n\nAdditional information\n\nS must be updated before T since the former depends on the latter's history.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.update_num_bins!","page":"API Reference","title":"OnlineLogBinning.update_num_bins!","text":"update_num_bins!(lacc::LevelAccumulator, [incr = 2])\n\nIncrement the number of bins accumulated by incr.\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineLogBinning.var_of_mean-Tuple{BinningAccumulator}","page":"API Reference","title":"OnlineLogBinning.var_of_mean","text":"var_of_mean( bacc::BinningAccumulator; [level = 0] )\n\nOnline measurement of the [BinningAccumulator] variance of the mean.\n\nAdditional information\n\nThis quantity is considered online despite that it is not regularly updated when data is push!ed from the stream.\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineLogBinning.var_of_mean-Tuple{LevelAccumulator}","page":"API Reference","title":"OnlineLogBinning.var_of_mean","text":"var_of_mean( lacc::LevelAccumulator ) = var(lacc) / lacc.num_bins\n\nOnline measurement of the [LevelAccumulator] variance of the mean.\n\nAdditional information\n\nThis quantity is considered online despite that it is not regularly updated when data is push!ed from the stream.\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.mean-Tuple{BinningAccumulator}","page":"API Reference","title":"Statistics.mean","text":"mean( bacc::BinningAccumulator; [level = 0] )\n\nOnline measurement of the [BinningAccumulator] mean.\n\nAdditional information\n\nThis quantity is considered online despite that it is not regularly updated when data is push!ed from the stream.\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.mean-Tuple{LevelAccumulator}","page":"API Reference","title":"Statistics.mean","text":"mean( lacc::LevelAccumulator )\n\nOnline measurement of the [LevelAccumulator] mean.\n\nAdditional information\n\nThis quantity is considered online despite that it is not regularly updated when data is push!ed from the stream.\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.std-Tuple{BinningAccumulator}","page":"API Reference","title":"Statistics.std","text":"std( bacc::BinningAccumulator )\n\nOnline measurement of the [BinningAccumulator] standard deviation.\n\nAdditional information\n\nThis quantity is considered online despite that it is not regularly updated when data is push!ed from the stream.\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.std-Tuple{LevelAccumulator}","page":"API Reference","title":"Statistics.std","text":"std( lacc::LevelAccumulator ) = sqrt(var(lacc))\n\nOnline measurement of the [LevelAccumulator] standard deviation.\n\nAdditional information\n\nThis quantity is considered online despite that it is not regularly updated when data is push!ed from the stream.\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.var-Tuple{BinningAccumulator}","page":"API Reference","title":"Statistics.var","text":"var( bacc::LevelAccumulator; [level = 0] )\n\nOnline measurement of the [BinningAccumulator] variance.\n\nAdditional information\n\nThis quantity is considered online despite that it is not regularly updated when data is push!ed from the stream.\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.var-Tuple{LevelAccumulator}","page":"API Reference","title":"Statistics.var","text":"var( lacc::LevelAccumulator )\n\nOnline measurement of the [LevelAccumulator] variance.\n\nAdditional information\n\nThis quantity is considered online despite that it is not regularly updated when data is push!ed from the stream.\n\n\n\n\n\n","category":"method"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"DocTestSetup = quote using OnlineLogBinning end","category":"page"},{"location":"why_binning/#Why-use-a-Binning-Analysis?","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"","category":"section"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"As described in Markus Wallerberger (2019), Vinay Ambegaokar, Matthias Troyer (2010), Tony F. Chan, Gene H. Golub, Randall J. LeVeque (1983), Carsten Bauer (2020), and James Gubernatis, Naoki Kawashima, Philipp Werner (2016), the presence of correlations in a data stream generated in Markov Chain Monte Carlo simulations renders any measures of error severely underestimated.","category":"page"},{"location":"why_binning/#Theoretical-background","page":"Why use a Binning Analysis?","title":"Theoretical background","text":"","category":"section"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"The naive approach is to calculate the mean and the variance of the mean, var_of_mean, for a given data stream X. For uncorrelated data, this becomes","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"beginaligned\nmathttmean(X) = frac1M sum_i = 1^M x_i\n\nmathttvar_of_mean(X) = frac1M(M-1) sum_i = 1^M (x_i - mathttmean(X))^2\nendaligned","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"Fortunately, in the presence of correlations, the mean doesn't change. Unfortunately, the var_of_mean does. Indeed, one can show that it's given by","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"mathttvar_of_mean(X) = frac1 + 2tau_XM(M-1) sum_i = 1^M (x_i - mathttmean(X))^2","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"where the as shown in the Figure within the Accumulator type hierarchy. Clearly, the uncorrelated var_of_mean is just increased by a factor of R_X equiv 1 + 2tau_X, where tau_X is defined as the integrated autocorrelation_time of the data stream. The binning analysis provides a fast as an O(N) method for calculating the autocorrelation_time. It's also cheap, only requiring O(log N) in RAM.  For those who are unfamiliar with the term, normally one would calculate tau_X by","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"tau_X = sum_i = 1^M sum_i  j left x_ix_j - mathttmean(x)^2 right","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"which is an  O(N^2) summation and can suffer from numerical instabilities.","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"As one performs pairwise means in each binning level to construct the next highest, and then calculates the var_of_mean for each level, one can see that it rises and then eventually saturates around a particular plateau value. Normalizing by the original var_of_mean calculation assuming the data stream is uncorrelated, one can then calculate R_X in the ell^rm th binning level as","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"R_X(ell) = fracmathttvar_of_mean(X^(ell))mathttvar_of_mean(X^(0)) = frac m^(ell) mathttvar(X^(ell))  mathttvar(X^(0)) ","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"where var is the normal variance and m^(ell) is the bin size, or the number of original data values accumulated into a single data point at the ell^rm th level.","category":"page"},{"location":"why_binning/#Visualizing-a-Binning-Analysis","page":"Why use a Binning Analysis?","title":"Visualizing a Binning Analysis","text":"","category":"section"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"The final result of the binning analysis, for sufficiently long data streams, will be to see a sigmoid-like curve. We've wrapped up a fitting and plotting workflow into the plot_binning_analysis function below to demonstrate how it works. Feel free to skip over to the Visualization Examples if you have your own workflow established.","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"using OnlineLogBinning, Plots, LaTeXStrings\npyplot()\n\n# Return the fitted inflection point\nsigmoid_inflection(fit) = fit.param[2] / fit.param[3]\n\n# Define a plotting function with Plots.jl\n# This function plots the RxValues, the Sigmoid fit,\n# the maximum trustworthy level, and the fitted \n# inflection point.\nfunction plot_binning_analysis(bacc)\n    # Plot the RxValues irrespective of the trusting cutoff\n    all_levels, all_rxvals = levels_RxValues(bacc, false)\n    plt = plot( all_levels, all_rxvals; \n                label = \"Binning Analysis\",\n                xlabel = L\"Bin Level $\\ell$\",\n                ylabel = L\"$R_X(\\ell)$\",\n                markershape = :circle,\n                legend = :topleft )\n\n    # Fit only the trustworthy levels\n    levels, rxvals = levels_RxValues(bacc)\n    fit = fit_RxValues(levels, rxvals)\n\n    # Plot the sigmoid fit\n    plot!(plt, all_levels, sigmoid(all_levels, fit.param);\n          label = \"Sigmoid Fit\")\n\n    # Plot the maximum trustworthy level\n    vline!(plt, [ max_trustworthy_level(bacc[level = 0].num_bins) ];\n           ls = :dash, color = \"gray\", \n           label = \"Maximum Trustworthy Level\")\n\n    # Plot the fitted inflection point if it's positive\n    if sigmoid_inflection(fit) > zero(fit.param[2])\n        vline!(plt, [ sigmoid_inflection(fit) ];\n               ls = :dot, color = \"red\", \n               label = \"Sigmoid Inflection Point\")\n    end\n    return plt\nend\n\nnothing # hide","category":"page"},{"location":"why_binning/#Visualization-Examples","page":"Why use a Binning Analysis?","title":"Visualization Examples","text":"","category":"section"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"Now we demonstrate four cases that tend to appear with binning analyses:","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"The binning analysis converges to a plateau for a correlated data stream R_X(ell rightarrow infty)  0.\nThe binning analysis reveals that the data stream is truly uncorrelated R_X(ell rightarrow infty) = 0.\nThe binning analysis has not converged because too few data were taken in the data stream to isolate the uncorrelated data.\nThe binning analyis has not convered because all of the data in the data stream are more-or-less equally correlated.","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"The first two cases are ideal. They represent situations where the data stream has enough data to distinguish correlated blocks from one another. In these first two cases, the BinningAnalysisResult will yield plateau_found == true.","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"The second two cases are not so ideal. Either way they show that the correlations in the data stream are so strong that individual uncorrelated blocks can not be robustly created and more sampling is required. Therefore, their BinningAnalysisResult yields plateau_found == false.","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"The data shown are pre-simulated signals generated by the TelegraphNoise.jl package (v0.1.0). Random telegraph signals have an analytically-defined autocorrelation time tau_X related to their average dwell time T_D by tau_X = T_D  2. Since the signals are random, they are saved previously, but I'll provide each chosen T_D for reproducibility purposes.","category":"page"},{"location":"why_binning/#example_plot_1","page":"Why use a Binning Analysis?","title":"Example 1: Clear R_X plateau at a finite value","text":"","category":"section"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"This first case shows the textbook (James Gubernatis, Naoki Kawashima, Philipp Werner (2016)) example of an R_X plateau found in a binning analysis. The dwell time for this signal was chosen to be T_D = 16, meaning tau_X = 8, and the signal generated was 2^18 = 262144 in length.","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"\n# Read in pre-simulated TelegraphNoise.jl data with a plateau\nsignal = zeros(Float64, Int(2^18))\nread!( joinpath(\"assets\", \"telegraph_plateau.bin\"), signal )\nbacc = BinningAccumulator()\npush!(bacc, signal)\n\nplot_binning_analysis(bacc)","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"DocTestSetup = quote\n    using OnlineLogBinning\n    signal = zeros(Float64, Int(2^18))\n    read!( joinpath(\"build\", \"assets\", \"telegraph_plateau.bin\"), signal )\n    bacc = BinningAccumulator()\n    push!(bacc, signal)\nend","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"result = fit_RxValues(bacc)\nresult.plateau_found\n\n# output\n\ntrue","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"Importantly, note that the fitted inflection point is greater than zero, but less than the maximum trustworthy level. The variations in the calculated R_X values for ell greater than the maximum trustworthy level are due to strong fluctuations because of small number statistics.","category":"page"},{"location":"why_binning/#example_plot_2","page":"Why use a Binning Analysis?","title":"Example 2: Uncorrelated data ~ R_X(ell rightarrow infty) = 0","text":"","category":"section"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"The dwell time for this signal was chosen to be T_D = 12, meaning tau_X = 14, and the signal generated was 2^14 = 16384 in length.","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"\n# Read in pre-simulated TelegraphNoise.jl data with a plateau\nsignal = zeros(Float64, Int(2^14))\nread!( joinpath(\"assets\", \"telegraph_uncorrelated.bin\"), signal )\nbacc = BinningAccumulator()\npush!(bacc, signal)\n\nplot_binning_analysis(bacc)","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"DocTestSetup = quote\n    using OnlineLogBinning\n    signal = zeros(Float64, Int(2^14))\n    read!( joinpath(\"build\", \"assets\", \"telegraph_uncorrelated.bin\"), signal )\n    bacc = BinningAccumulator()\n    push!(bacc, signal)\nend","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"result = fit_RxValues(bacc)\nresult.plateau_found\n\n# output\n\ntrue","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"DocTestSetup = nothing","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"Notice that the R_X values decay for increasing ell. This is because the binning analysis cannot detect any smaller blocks of uncorrelated data since the original data stream is indeed correlated.","category":"page"},{"location":"why_binning/#example_plot_3","page":"Why use a Binning Analysis?","title":"Example 3: No plateau due to data insufficiency","text":"","category":"section"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"For insufficiently long data streams, we do not expect a plateau, as shown in the following case:","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"\n# Read in pre-simulated TelegraphNoise.jl data without a plateau\nsignal = zeros(Float64, Int(2^10))\nread!( joinpath(\"assets\", \"telegraph_no_plateau.bin\"), signal )\nbacc = BinningAccumulator()\npush!(bacc, signal)\n\nplot_binning_analysis(bacc)","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"DocTestSetup = quote\n    using OnlineLogBinning\n    signal = zeros(Float64, Int(2^10))\n    read!( joinpath(\"build\", \"assets\", \"telegraph_no_plateau.bin\"), signal )\n    bacc = BinningAccumulator()\n    push!(bacc, signal)\nend","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"result = fit_RxValues(bacc)\nresult.plateau_found\n\n# output\n\nfalse","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"DocTestSetup = nothing","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"Here, the dwell time was chosen to be T_D = 256, meaning tau_X = 128, and the signal generated was 2^10 = 1024 in length. Notice, that the binning analysis began to pick up on a set of uncorrelated blocks, but there was not enough simulated data to reveal them before the maximum trustworthy level was reached. In a case like this, one would simply need to run their simulation about 64 times longer reveal a fitted plateau.","category":"page"},{"location":"why_binning/#example_plot_4","page":"Why use a Binning Analysis?","title":"Example 4: No plateau due to totally-correlated data","text":"","category":"section"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"In this final example, we demonstrate what happens for a data stream that has \"frozen-in\" correlations. By this, we mean one where the autocorrelation time tau_X far exceeds the data stream size. For this case, T_D = 2^16 = 65536, so tau_X = 2^15 = 32768, while the signal length is only 2^12 = 4096.","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"\n# Read in pre-simulated TelegraphNoise.jl data with a plateau\nsignal = zeros(Float64, Int(2^12))\nread!( joinpath(\"assets\", \"telegraph_totally_correlated.bin\"), signal )\nbacc = BinningAccumulator()\npush!(bacc, signal)\n\nplot_binning_analysis(bacc)","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"DocTestSetup = quote\n    using OnlineLogBinning\n    signal = zeros(Float64, Int(2^12))\n    read!( joinpath(\"build\", \"assets\", \"telegraph_totally_correlated.bin\"), signal )\n    bacc = BinningAccumulator()\n    push!(bacc, signal)\nend","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"result = fit_RxValues(bacc)\nresult.plateau_found\n\n# output\n\nfalse","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"DocTestSetup = nothing","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"In this case, eventually the binning analysis returns R_X = 0, since the blocks start comparing literally identical elements. Notice that this case would return a plateau_found if it were not for the check if any of the R_X values were too small. (In principle this case also would result from a data stream with a defined periodicity, despite having correlations, but this is unavoidable.)","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"tip: Tip\nThis is the most dangerous case to automate because the variance of such a data stream is naturally very small relative to the mean. As is the case with all Monte Carlo simulations, or statistical data streams, one should be very wary when the error is a mathematical zero, or vanishingly small compared to the calculated mean.","category":"page"},{"location":"why_binning/","page":"Why use a Binning Analysis?","title":"Why use a Binning Analysis?","text":"DocTestSetup = nothing","category":"page"},{"location":"related_packages/","page":"Related Packages","title":"Related Packages","text":"DocTestSetup = quote using OnlineLogBinning end","category":"page"},{"location":"related_packages/#Related-packages","page":"Related Packages","title":"Related packages","text":"","category":"section"},{"location":"related_packages/","page":"Related Packages","title":"Related Packages","text":"BinningAnalysis.jl for a very similar Julia package which served as an inspiration for this one. Our package does not have as broad of a scope as theirs.\nOne of the authors of BinningAnalysis.jl also wrote Ref. Carsten Bauer (2020) which gives a great introduction to the statistical analysis of Monte Carlo data.\nOnlineStats.jl for many more online statistics and routines, most of which are beyond the scope of this package.","category":"page"},{"location":"related_packages/","page":"Related Packages","title":"Related Packages","text":"DocTestSetup = nothing","category":"page"},{"location":"accumulators/","page":"Accumulator Hierarchy","title":"Accumulator Hierarchy","text":"DocTestSetup = quote using OnlineLogBinning end","category":"page"},{"location":"accumulators/#OnlineLogBinning's-Accumulator-structs","page":"Accumulator Hierarchy","title":"OnlineLogBinning's Accumulator structs","text":"","category":"section"},{"location":"accumulators/#Accumulator-type-hierarchy","page":"Accumulator Hierarchy","title":"Accumulator type hierarchy","text":"","category":"section"},{"location":"accumulators/","page":"Accumulator Hierarchy","title":"Accumulator Hierarchy","text":"(Image: BinningAccumulatorDiagram)","category":"page"},{"location":"accumulators/","page":"Accumulator Hierarchy","title":"Accumulator Hierarchy","text":"We implement this with three nested Accumulator structs: the outermost BinningAccumulator, the middle-level LevelAccumulator, and the innermost PairAccumulator. The BinningAccumulator stores a Vector of LevelAccumulator, each of which store their own PairAccumulator.","category":"page"},{"location":"accumulators/#The-[BinningAccumulator](@ref)","page":"Accumulator Hierarchy","title":"The BinningAccumulator","text":"","category":"section"},{"location":"accumulators/","page":"Accumulator Hierarchy","title":"Accumulator Hierarchy","text":"This is the main interface to the binning statistics of a given data stream. The user should basically only mess with this type of object. The binning analysis is performed using it and all important statistical quantities can be found from it.","category":"page"},{"location":"accumulators/","page":"Accumulator Hierarchy","title":"Accumulator Hierarchy","text":"A BinningAccumulator is a wrapper around a Vector of LevelAccumulators. For a given data stream of size N, there are rm floorlog_2(N) binning levels. The BinningAccumulator has a length which is one more than the total number of binning levels, where the bottom-most level, level = 0, represents the unbinned data.","category":"page"},{"location":"accumulators/#The-[LevelAccumulator](@ref)","page":"Accumulator Hierarchy","title":"The LevelAccumulator","text":"","category":"section"},{"location":"accumulators/","page":"Accumulator Hierarchy","title":"Accumulator Hierarchy","text":"This data structure keeps track of the online mean and variance for a given level. These accumulated values are only updated though after a pair from the data stream has been read in through the LevelAccumulator's PairAccumulator.","category":"page"},{"location":"accumulators/#The-[PairAccumulator](@ref)","page":"Accumulator Hierarchy","title":"The PairAccumulator","text":"","category":"section"},{"location":"accumulators/","page":"Accumulator Hierarchy","title":"Accumulator Hierarchy","text":"This is the outward-facing data structure to a given data stream. Once a pair from the data stream has been read, then the mean and variance accumulators are updated for a given level, and then the mean is propagated to the next binning level, where the process is repeated. This implements the logarithmic binning analysis.","category":"page"},{"location":"accumulators/","page":"Accumulator Hierarchy","title":"Accumulator Hierarchy","text":"DocTestSetup = nothing","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = quote using OnlineLogBinning end","category":"page"},{"location":"#OnlineLogBinning-[![Github-Link](assets/GitHub-Mark-Light-32px.png)](https://github.com/meese-wj/OnlineLogBinning.jl)","page":"Home","title":"OnlineLogBinning (Image: Github Link)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia package to determine effective number of uncorrelated data points in a correlated data stream via an O(log N) online binning algorithm.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use this package, one adds it in any usual Julian way, for example, by simply pressing ] in the Julia REPL to enter pkg mode, and then by typing the following","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add OnlineLogBinning","category":"page"},{"location":"","page":"Home","title":"Home","text":"to download OnlineLogBinning.jl from Julia's General Registries. (Remember to press Backspace to leave pkg mode.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"why_binning.md\", \"accumulators.md\", \"example.md\", \"math.md\", \"related_packages.md\", \"api.md\"]\nDepth = 5","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = nothing","category":"page"},{"location":"math/#The-Math-Behind-OnlineLogBinning","page":"Mathematical Details","title":"The Math Behind OnlineLogBinning","text":"","category":"section"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"The online binning functionality works by combining the method described in Section D of Markus Wallerberger (2019), as well as in the Dicussion of Vinay Ambegaokar, Matthias Troyer (2010), where one keeps track of several accumulators, with the first-pass pairwise algorithm from Tony F. Chan, Gene H. Golub, Randall J. LeVeque (1983). The online (i.e. O(1)) quantities that are obtained from this process are the Tvalue, T, and Svalue, S, from Tony F. Chan, Gene H. Golub, Randall J. LeVeque (1983), representing the total accumulator and square accumulator, respectively, as well as the total number of bins m. Together, these online quantities can be combined at any point to yield other (technically) online statistics like the mean or variance. These statistics are online in the sense that they are simple function of online accumulators, and so we emphasize their calculation is still amortized with complexity O(1). This is despite that the mean, variance, etc. are not updated continuously; only m, T, and S are.","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"Using the notation of Ref. Tony F. Chan, Gene H. Golub, Randall J. LeVeque (1983), the T and S calculated in a data stream comprised of a sequence of m elements,","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"x_k in leftlbrace x_1x_2dotsx_mrightrbrace","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"is given by","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"T_1m = sum_k = 1^m x_k","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"S_1m = sum_k = 1^m left(x_k - barx right)^2","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"where the mean is given by","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"barx = fracT_1mm","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"The variance is then given by","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"sigma^2 = fracS_1mm-1","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"These two quantities can be computed online with the first-pass pairwise algorithm given an additional two elements leftlbrace x_m+1 x_m+2 rightrbrace using the following expressions:","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"T_1m + 2 = T_1m + T_m+1m+2","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"S_1m + 2 = S_1 m + S_m+1 m+2 + fracm2(m+2) left( frac2m T_1m - T_m+1m+2 right)^2","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"where","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"T_m+1m+2 = x_m+1 + x_m+2","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"S_m+1 m+2 = frac12left(x_m+2 - x_m+1 right)^2","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"We implement this with three nested Accumulator structs: the outermost BinningAccumulator, the middle-level LevelAccumulator, and the innermost PairAccumulator. The BinningAccumulator stores a Vector of LevelAccumulators, each of which store their own PairAccumulator.","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"The PairAccumulator struct is the outward facing element of the BinningAccumulator in that it takes in data directly from the data stream. After a pair of values has been imported from the stream, then leftlbrace T_m+1m+2 S_m+1m+2 rightrbrace are computed and exported to the encapsulating LevelAccumulator, where the leftlbrace m T_1m S_1m rightrbrace accumulator values are stored. Then, the PairAccumulator is reset!. At the same time, the outermost BinningAccumulator passes the T_m+1m+2  2 (ie the pairwise mean) value onto the PairAccumulator in the LevelAccumulator at the next binning level, where the whole process is repeated again, except the accumulated T_1m+2  2 values comprise the new data stream.","category":"page"},{"location":"math/","page":"Mathematical Details","title":"Mathematical Details","text":"The fact that the data stream is processed in pairs before being passed along to the other binning levels inherently leads to a bin_depth given by rm floorleftlog_2 (m)right, which is the total number of binning levels in the data stream.","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"DocTestSetup = quote using OnlineLogBinning end","category":"page"},{"location":"example/#How-to-use-OnlineLogBinning","page":"Example Usage","title":"How to use OnlineLogBinning","text":"","category":"section"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"First, construct an empty [BinningAccumulator] with of T <: Number parametric type. Let's take the default T = Float64 as an example.","category":"page"},{"location":"example/#Initialization","page":"Example Usage","title":"Initialization","text":"","category":"section"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"To start, initialize a BinningAccumulator{T}:","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"julia> bacc = BinningAccumulator()\nBinningAccumulator{Float64} with 0 binning levels.\n0th Binning Level (unbinned data):\nLevelAccumulator{Float64} with online fields:\n    level    = 0\n    num_bins = 0\n    Taccum   = 0.0\n    Saccum   = 0.0\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = NaN\n    Current Variance         = -0.0\n    Current Std. Deviation   = -0.0\n    Current Var. of the Mean = NaN\n    Current Std. Error       = NaN","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"note: Note\nWe currently only support Float types, i.e. T <: AbstractFloat or T is a Complex{Float#}. The tested types are listed in OLB_tested_numbers.","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"Alternatively, if one has an anticipated data stream size in mind, one may pre-allocate a completely empty BinningAccumulator as","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"using OnlineLogBinning # hide\nstream_length = 12\nbacc_prealloc = BinningAccumulator(stream_length)   # using the default `Float64` type","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"compat: Compat\nThe pre-allocated functionality requires at least version 0.2.2.","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"Once initialized, then one push!es either a single value or a data stream (sequence of values of itr type) to the BinningAccumulator. The online analysis will be taken care of automatically.","category":"page"},{"location":"example/#Accumulate-data","page":"Example Usage","title":"Accumulate data","text":"","category":"section"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"The easiest way to accumulate data from a data stream is by push!ing a single value into the BinningAccumulator.","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"julia> push!(bacc, 1)\nBinningAccumulator{Float64} with 0 binning levels.\n0th Binning Level (unbinned data):\nLevelAccumulator{Float64} with online fields:\n    level    = 0\n    num_bins = 0\n    Taccum   = 0.0\n    Saccum   = 0.0\n    Paccum   = PairAccumulator{Float64}(false, [0.0, 1.0])\n\n    Calculated Level Statistics:\n    Current Mean             = NaN\n    Current Variance         = -0.0\n    Current Std. Deviation   = -0.0\n    Current Var. of the Mean = NaN\n    Current Std. Error       = NaN\n","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"note: Note\nValues of incorrect type are converted to the correct type internally.","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"Additionally, one can push! a data stream into the BinningAccumulator:","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"julia> push!(bacc, [1, 2, 3, 4, 3, 2, 1])\nBinningAccumulator{Float64} with 3 binning levels.\n0th Binning Level (unbinned data):\nLevelAccumulator{Float64} with online fields:\n    level    = 0\n    num_bins = 8\n    Taccum   = 17.0\n    Saccum   = 8.875\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = 2.125\n    Current Variance         = 1.2678571428571428\n    Current Std. Deviation   = 1.1259916264596033\n    Current Var. of the Mean = 0.15848214285714285\n    Current Std. Error       = 0.3980981573144277\n\n1th Binning Level:\nLevelAccumulator{Float64} with online fields:\n    level    = 1\n    num_bins = 4\n    Taccum   = 8.5\n    Saccum   = 3.6875\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = 2.125\n    Current Variance         = 1.2291666666666667\n    Current Std. Deviation   = 1.1086778913041726\n    Current Var. of the Mean = 0.3072916666666667\n    Current Std. Error       = 0.5543389456520863\n\n2th Binning Level:\nLevelAccumulator{Float64} with online fields:\n    level    = 2\n    num_bins = 2\n    Taccum   = 4.25\n    Saccum   = 0.28125\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = 2.125\n    Current Variance         = 0.28125\n    Current Std. Deviation   = 0.5303300858899106\n    Current Var. of the Mean = 0.140625\n    Current Std. Error       = 0.375\n\n3th Binning Level:\nLevelAccumulator{Float64} with online fields:\n    level    = 3\n    num_bins = 0\n    Taccum   = 0.0\n    Saccum   = 0.0\n    Paccum   = PairAccumulator{Float64}(false, [0.0, 2.125])\n\n    Calculated Level Statistics:\n    Current Mean             = NaN\n    Current Variance         = -0.0\n    Current Std. Deviation   = -0.0\n    Current Var. of the Mean = NaN\n    Current Std. Error       = NaN","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"note: Note\nThe highest binning level will typically yield useless NaN statistics, but that just reflects the fact that the num_bins, Taccum, and Saccum accumulators are only updated once the level's PairAccumulator is full.","category":"page"},{"location":"example/#Available-online-statistics","page":"Example Usage","title":"Available online statistics","text":"","category":"section"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"One can then calculate the following statistics from the BinningAccumulator at any binning level = lvl:","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"mean(bacc::BinningAccumulator; level = lvl)           # arithmetic mean\nvar(bacc::BinningAccumulator; level = lvl)            # sample variance \nstd(bacc::BinningAccumulator; level = lvl)            # sample standard deviation \nvar_of_mean(bacc::BinningAccumulator; level = lvl)    # variance of the mean \nstd_error(bacc::BinningAccumulator; level = lvl)      # standard error of the mean ","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"The binning level is optional. By default, the binning level is set to level = 0. This level, accessed by bacc[level = 0], represents the unbinnned statistics from of the original data stream. The LevelAccumulators from any binning level can also be extracted using the overloaded [] notation as","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"julia> bacc[level = 0]\nLevelAccumulator{Float64} with online fields:\n    level    = 0\n    num_bins = 8\n    Taccum   = 17.0\n    Saccum   = 8.875\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = 2.125\n    Current Variance         = 1.2678571428571428\n    Current Std. Deviation   = 1.1259916264596033\n    Current Var. of the Mean = 0.15848214285714285\n    Current Std. Error       = 0.3980981573144277\n\njulia> bacc[level = 1]\nLevelAccumulator{Float64} with online fields:\n    level    = 1\n    num_bins = 4\n    Taccum   = 8.5\n    Saccum   = 3.6875\n    Paccum   = PairAccumulator{Float64}(true, [0.0, 0.0])\n\n    Calculated Level Statistics:\n    Current Mean             = 2.125\n    Current Variance         = 1.2291666666666667\n    Current Std. Deviation   = 1.1086778913041726\n    Current Var. of the Mean = 0.3072916666666667\n    Current Std. Error       = 0.5543389456520863","category":"page"},{"location":"example/#Perform-the-Binning-Analysis","page":"Example Usage","title":"Perform the Binning Analysis","text":"","category":"section"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"Once a sufficient amount of data has been binned, one can employ the BinningAnalysis routines found in BinningAnalysis.jl. To show how this works, we make use of a pre-prepared random telegraph signal generated with the TelegraphNoise.jl package. The signal is stored as a binary file in docs/src/assets.","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"The simplest one to use is fit_RxValues that takes in a single required BinningAccumulator as an argument.","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"julia> signal = zeros(Float64, Int(2^18));\n\njulia> read!( joinpath(\"build\", \"assets\", \"telegraph_plateau.bin\"), signal);\n\njulia> bacc = BinningAccumulator();\n\njulia> push!(bacc, signal);\n\njulia> result = fit_RxValues(bacc)\nBinning Analysis Result:\n    Plateau Present:             true\n    Fitted Rx Plateau:           14.611315366653367\n    Autocorrelation time τₓ:     6.805657683326683\n    Effective Datastream Length: 17941\n    Binning Analysis Mean:       0.00440216064453125\n    Binning Analysis Error:      0.007465747493169594","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"The Plateau Present flag indicates whether a sigmoid fit to the RxValues is reasonable so as to take its plateau seriously. (See _plateau_found for details.) The value of the fitted plateau is also returned. If Plateau Present == false, then the plateau is set to be the size of the data stream. This is because the effective number of uncorrelated values in the data stream of size M is given by M_rm eff = M  R_X.","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"Other quantities can be extracted from the BinningAnalysisResult, for example, the autocorrelation_time and the effective_uncorrelated_values in the data stream.","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"julia> autocorrelation_time(result)\n6.805657683326683\n\njulia> effective_uncorrelated_values(result)\n17941","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"Additionally, as of v0.4, one can also export a BinningAnalysisResult as a Measurement from Measurements.jl:","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"julia> measurement(result)\n0.0044 ± 0.0075","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"and then one can fully take advantage of propagated errors thanks to that wonderful package!","category":"page"},{"location":"example/","page":"Example Usage","title":"Example Usage","text":"DocTestSetup = nothing","category":"page"}]
}
